<!DOCTYPE html>
<html lang="en">
  <head>
    <head>
      <meta charset="UTF-8">
      <title>RxPlayer - CANAL+ (stand-alone demo)</title>
    </head>
    <body>
      <video id="video"></video>
      <script type="text/javascript" src="./lib.js" charset="utf-8"></script>
      <script charset="utf-8">
        const player = new window.RxPlayer({
          videoElement: document.getElementById("video")
        });

        window.player = player;

        /**
         * construct string from the code units given
         * @param {Uint16Array|Uint8Array} bytes
         * @returns {string}
         */
        function bytesToStr(bytes) {
          return String.fromCharCode.apply(null, bytes);
        }

        /**
         * Convert a simple string to an Uint8Array containing the corresponding
         * UTF-8 code units.
         * /!\ its implementation favors simplicity and performance over accuracy.
         * Each character having a code unit higher than 255 in UTF-16 will be
         * truncated (real value % 256).
         * Please take that into consideration when calling this function.
         * @param {string} str
         * @returns {Uint8Array}
         */
        function strToBytes(str) {
          const len = str.length;
          const arr = new Uint8Array(len);
          for (let i = 0; i < len; i += 1) {
            arr[i] = str.charCodeAt(i) & 0xFF;
          }
          return arr;
        }

        /**
         * construct string from the code units given.
         * Only use every other byte for each UTF-16 character.
         * @param {Uint8Array} bytes
         * @returns {string}
         */
        function bytesToUTF16Str(bytes) {
          let str = "";
          const len = bytes.length;
          for (let i = 0; i < len; i += 2) {
            str += String.fromCharCode(bytes[i]);
          }
          return str;
        }

        function formatPlayreadyChallenge(challenge) {
          const str = bytesToUTF16Str(challenge);
          const match = /<Challenge encoding="base64encoded">(.*)<\/Challenge>/.exec(str);
          const xml = match ?
            atob(match[1]) : /* IE11 / EDGE */
            bytesToStr(new Uint8Array(challenge)); // Chromecast
          return xml;
        }

        const getLicense = (rawChallenge) => {
          const challenge = formatPlayreadyChallenge(rawChallenge);
          const xhr = new XMLHttpRequest();
          xhr.open("POST", "https://test.playready.microsoft.com/service/rightsmanager.asmx", true);
          return new Promise((resolve, reject) => {
            xhr.onerror = () => {
              const error = new Error("getLicense's request failed on an error");
              error.fallbackOnLastTry = fallbackOnLastTry;
              reject(error);
            };
            xhr.onload = (evt) => {
              if (xhr.status >= 200 && xhr.status < 300) {
                const license = evt.target.response;
                resolve(license);
              } else {
                const error = new Error("getLicense's request finished with a " +
                                        `${xhr.status} HTTP error`);
                error.noRetry = fallbackOnLastTry;
                error.fallbackOnLastTry = fallbackOnLastTry;
                reject(error);
              }
            };
            xhr.setRequestHeader("content-type", "text/xml; charset=utf-8");
            xhr.send(challenge);
          }).then(license =>
            typeof license === "string" ? strToBytes(license).buffer : license
          );
        };

        player.loadVideo({
          url : "https://demo.unified-streaming.com/video/tears-of-steel/tears-of-steel-dash-playready.ism/.mpd",
          transport: "dash",
          autoPlay: true,
          keySystems: [
            { type: "playready",
              persistentStateRequired: true,
              distinctiveIdentifierRequired: true,
              getLicense }
          ],
        })
      </script>
    </body>

</html>
