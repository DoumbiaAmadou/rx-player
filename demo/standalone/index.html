<!DOCTYPE html>
<html lang="en">
  <head>
    <head>
      <meta charset="UTF-8">
      <title>RxPlayer - CANAL+ (stand-alone demo)</title>
    </head>
    <body>
      <video id="video"></video>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/promise-polyfill/8.2.0/polyfill.min.js" charset="utf-8"></script>
      <script type="text/javascript" src="./lib.js" charset="utf-8"></script>
      <script charset="utf-8">
        /**
         * @param {Array.<Object>} drmInfos
         * @param {Object} fallbacks
         * @returns {Promise.<Array.<Object>>}
         */
        function getKeySystemsOption(
          drmInfos,
          opts
        ) {
          var wantedDRMs = drmInfos
            .map(function (drmInfo) {
              return {
                drm: drmInfo.drm,
                licenseServerUrl: drmInfo.licenseServerUrl,
                serverCertificateUrl: drmInfo.serverCertificateUrl,
                fallbackKeyError: opts.fallbackKeyError,
                fallbackLicenseRequest: opts.fallbackLicenseRequest
              };
            })
            .filter(function (drmInfo) {
              return drmInfo.drm !== undefined;
            });

          return parseDRMConfigurations(wantedDRMs);
        }
        function parseDRMConfigurations(drmConfigurations) {
          return Promise.all(drmConfigurations.map(function (drmConfig) {
            var drm = drmConfig.drm;
            var fallbackKeyError = drmConfig.fallbackKeyError;
            var fallbackLicenseRequest = drmConfig.fallbackLicenseRequest;
            var licenseServerUrl = drmConfig.licenseServerUrl;
            var serverCertificateUrl = drmConfig.serverCertificateUrl;

            if (!licenseServerUrl) {
              return ;
            }

            var type = drm.toLowerCase();
            var keySystem = {
              type: type,
              getLicense: generateGetLicense(licenseServerUrl,
                                             type,
                                             !!fallbackLicenseRequest),
              fallbackOn: {
                keyInternalError: !!fallbackKeyError,
                keyOutputRestricted: !!fallbackKeyError,
              },
            };

            if (!serverCertificateUrl) {
              return keySystem;
            }

            return getServerCertificate(serverCertificateUrl)
              .then(function (serverCertificate) {
                keySystem.serverCertificate = serverCertificate;
                return keySystem;
              });
          })).then(function(keySystems) {
            return keySystems.filter(function(ks) { return  ks; });
          });
        }

        function getServerCertificate(url) {
          return new Promise(function (resolve, reject) {
            var xhr = new XMLHttpRequest();
            xhr.open("GET", url, true);
            xhr.responseType = "arraybuffer";
            xhr.onload = function (evt) {
              if (xhr.status >= 200 && xhr.status < 300) {
                var serverCertificate = evt.target.response;
                resolve(serverCertificate);
              } else {
                reject();
              }
            };
            xhr.onerror = function (err) {
              reject(err);
            };
            xhr.send();
          });
        }

        function formatPlayreadyChallenge(challenge) {
          var str = leUtf16ToStr(challenge);
          var match = /<Challenge encoding="base64encoded">(.*)<\/Challenge>/.exec(str);
          var xml = match ?
            atob(match[1]) : /* IE11 / EDGE */
            utf8ToStr(challenge); // Chromecast
          return xml;
        }

        function generateGetLicense(licenseServerUrl, drmType, fallbackOnLastTry) {
          var isPlayready = drmType.indexOf("playready") !== -1;
          return function(rawChallenge) {
            var challenge =  isPlayready ?
              formatPlayreadyChallenge(rawChallenge) :
              rawChallenge;
            var xhr = new XMLHttpRequest();
            xhr.open("POST", licenseServerUrl, true);
            return new Promise(function (resolve, reject) {
              xhr.onerror = function () {
                var error = new Error("getLicense's request failed on an error");
                error.fallbackOnLastTry = fallbackOnLastTry;
                reject(error);
              };
              xhr.onload = function (evt) {
                if (xhr.status >= 200 && xhr.status < 300) {
                  var license = evt.target.response;
                  resolve(license);
                } else {
                  var error = new Error("getLicense's request finished with a " +
                                          "${xhr.status} HTTP error");
                  error.noRetry = fallbackOnLastTry;
                  error.fallbackOnLastTry = fallbackOnLastTry;
                  reject(error);
                }
              };
              if (isPlayready) {
                xhr.setRequestHeader("content-type", "text/xml; charset=utf-8");
              } else {
                xhr.responseType = "arraybuffer";
              }
              xhr.send(challenge);
            }).then(function (license) {
              return isPlayready && typeof license === "string" ?
                strToUtf8(license) :
                license;
            });
          };
        }
        /**
         * Creates a string from the given Uint8Array containing utf-8 code units.
         * @param {Uint8Array} bytes
         * @returns {string}
         */
        function utf8ToStr(data) {
          var uint8 = data;

          // If present, strip off the UTF-8 BOM.
          if (uint8[0] === 0xEF && uint8[1] === 0xBB && uint8[2] === 0xBF) {
            uint8 = uint8.subarray(3);
          }

          // We're basically doing strToUtf8 in reverse.
          // You can look at that other function for the whole story.

          // Generate string containing escaped UTF-8 code units
          var utf8Str = stringFromCharCodes(uint8);

          var escaped;
          if (typeof window.escape !== "function") {
            // Transform UTF-8 escape sequence into percent-encoded escape sequences.
            escaped = escape(utf8Str);
          } else {
            // Let's implement a simple escape function
            // http://ecma-international.org/ecma-262/9.0/#sec-escape-string
            var nonEscapedChar = /[A-Za-z0-9*_+-./]/;
            escaped = "";
            for (var i = 0; i < utf8Str.length; i++) {
              if (nonEscapedChar.test(utf8Str[i])) {
                escaped += utf8Str[i];
              } else {
                var charCode = utf8Str.charCodeAt(i);
                escaped += charCode >= 256 ?
                  "%u" + intToHex(charCode, 4) :
                  "%" + intToHex(charCode, 2);
              }
            }
          }

          // Decode the percent-encoded UTF-8 string into the proper JS string.
          // Example: "g#%E3%82%AC" -> "g#€"
          return decodeURIComponent(escaped);
        }
        /**
         * Convert a string to an Uint8Array containing the corresponding UTF-8 code
         * units.
         * @param {string} str
         * @returns {Uint8Array}
         */
        function strToUtf8(str) {
          // http://stackoverflow.com/a/13691499 provides an ugly but functional solution.
          // (Note you have to dig deeper to understand it but I have more faith in
          // stackoverflow not going down in the future so I leave that link.)

          // Briefly said, `utf8Str` will contain a version of `str` where every
          // non-ASCII characters will be replaced by an escape sequence of the
          // corresponding representation of those characters in UTF-8.
          // It does sound weird and unnecessarily complicated, but it works!
          //
          // Here is actually what happens with more words. We will rely on two browser
          // APIs:
          //
          //   - `encodeURIComponent` will take a string and convert the non-ASCII
          //     characters in it into the percent-encoded version of the corresponding
          //     UTF-8 bytes
          //     Example: encodeURIComponent("é") => 0xC3 0xA9 => `"%C3%A9"`
          //
          //   - `unescape` unescapes (so far so good) a percent-encoded string. But it
          //     does it in a really simple way: percent-encoded byte by percent-encoded
          //     byte into the corresponding extended ASCII representation on 8 bits.
          //     As a result, we end-up with a string which actually contains instead of
          //     each of its original characters, the UTF-8 code units (8 bits) of
          //     those characters.
          //     Let's take our previous `"é" => "%C3%A9"` example. Here we would get:
          //     unecape("%C3%A9") => "\u00c3\u00a9" === "Ã©" (in extended ASCII)
          //
          // By iterating on the resulting string, we will then be able to generate a
          // Uint8Array containing the UTF-8 representation of that original string, by
          // just calling the charCodeAt API on it.
          var utf8Str;
          var pcStr = encodeURIComponent(str);

          // As "unescape" is a deprecated function we want to declare a fallback in the
          // case a browser decide to not implement it.
          if (typeof window.unescape === "function") {
            utf8Str = unescape(pcStr);
          } else {
            // simple unescape function
            // http://ecma-international.org/ecma-262/9.0/#sec-unescape-string
            var isHexChar = /[0-9a-fA-F]/;
            var pcStrLen = pcStr.length;
            utf8Str = "";
            for (var i = 0; i < pcStr.length; i++) {
              var wasPercentEncoded = false;
              if (pcStr[i] === "%") {
                if (i <= pcStrLen - 6 &&
                    pcStr[i + 1] === "u" &&
                    isHexChar.test(pcStr[i + 2]) &&
                    isHexChar.test(pcStr[i + 3]) &&
                    isHexChar.test(pcStr[i + 4]) &&
                    isHexChar.test(pcStr[i + 5]))
                {
                  var charCode = parseInt(pcStr.substring(i + 1, i + 6), 16);
                  utf8Str += String.fromCharCode(charCode);
                  wasPercentEncoded = true;
                  i += 5; // Skip the next 5 chars
                } else if (i <= pcStrLen - 3 &&
                    isHexChar.test(pcStr[i + 1]) &&
                    isHexChar.test(pcStr[i + 2]))
                {
                  var charCode = parseInt(pcStr.substring(i + 1, i + 3), 16);
                  utf8Str += String.fromCharCode(charCode);
                  wasPercentEncoded = true;
                  i += 2; // Skip the next 2 chars
                }
              }
              if (!wasPercentEncoded) {
                utf8Str += pcStr[i];
              }
            }
          }

          // Now let's just build our array from every other bytes of that string's
          // UTF-16 representation
          var res = new Uint8Array(utf8Str.length);
          for (var i = 0; i < utf8Str.length; i++) {
            res[i] = utf8Str.charCodeAt(i) & 0xFF; // first byte should be 0x00 anyway
          }
          return res;
        }
        /**
         * Construct string from the little-endian UTF-16 code units given.
         * @param {Uint8Array} bytes
         * @returns {string}
         */
        function leUtf16ToStr(bytes) {
          var str = "";
          for (var i = 0; i < bytes.length; i += 2) {
            str += String.fromCharCode((bytes[i + 1] << 8) + bytes[i]);
          }
          return str;
        }

        var player = new window.RxPlayer({
          videoElement: document.getElementById("video")
        });

        getKeySystemsOption([{
          "licenseServerUrl": "https://test.playready.microsoft.com/service/rightsmanager.asmx?PlayRight=1&UseSimpleNonPersistentLicense=1",
          "drm": "Playready",
        }], {}).then(function(ks) {
          player.loadVideo({
            "url": "https://demo.unified-streaming.com/video/tears-of-steel/tears-of-steel-dash-playready.ism/.mpd",
            transport: "dash",
            autoPlay: true,
            keySystems: ks,
          });
        });

        window.player = player;
      </script>
    </body>

</html>
